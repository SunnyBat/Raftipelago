using Steamworks;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Raftipelago
{
    // We could make extensions, but I don't want to have this in IntelliSense in case it implies
    // that the function is in Raft (thus making it more reliable when updates happen) instead of
    // in our code. Because of this, extensions should not be used for Raft classes.
    public class CommonUtils
    {
        private const ulong ArchipelagoIdentifierBit = 0x10000;
        private const ulong ArchipelagoPlayerIdBitsMask = 0xFFFF;
        private const ulong AllArchipelagoBitsMask = 0x1FFFF;

        public static bool IsNote(LandmarkItem item)
        {
            var name = item?.name ?? "";
            return name.Contains("NoteBookPickup");
        }
        public static bool IsBlueprint(LandmarkItem item)
        {
            var name = item?.name ?? "";
            return name.Contains("Blueprint");
        }
        public static bool IsNoteOrBlueprint(LandmarkItem item)
        {
            return IsNote(item) || IsBlueprint(item);
        }

        public static bool IsValidNote(NoteBookNote note)
        {
            return note?.name?.Contains("NoteBookNote") ?? false;
        }

        public static bool IsValidResearchTableItem(Item_Base item)
        {
            return item.settings_recipe.CraftingCategory != CraftingCategory.Hidden
                && item.settings_recipe.CraftingCategory != CraftingCategory.Decorations
                && item.settings_recipe.CraftingCategory != CraftingCategory.CreativeMode
                && item.settings_recipe.CraftingCategory != CraftingCategory.Skin
                && !item.settings_recipe.LearnedFromBeginning;
        }

        /// <summary>
        /// Gets the Archipelago Player ID from a SteamID. The SteamID given should NOT be a valid SteamID,
        /// but should instead be one generated by Raftipelago.
        /// </summary>
        /// <param name="steamId">The Raftipelago-generated SteamID</param>
        /// <param name="playerId">The parsed Player ID, or 0 if not a Raftipelago-generated SteamID</param>
        /// <returns>True if steamId was a valid Raftipelago-generated SteamID, otherwise false</returns>
        public static bool TryGetArchipelagoPlayerIdFromSteamId(ulong steamId, out int playerId)
        {
            // See https://developer.valvesoftware.com/wiki/SteamID for how to parse Steam IDs.
            // We're using the fact that the Universe for a Steam ID is Invalid at 0 to tell us
            // that this is an Archipelago player. This allows us to pass back Steam IDs without
            // having to override a bunch of additional methods and not accidentally conflict
            // with valid Steam IDs while doing so.
            // In our case, our custom SteamID is in the range 0x10000 - 0x1FFFF
            if (
                // XOR to check bits 18-64 are 0 so we know this is considered an invalid SteamID
                (steamId & (long.MaxValue - 0x1FFFF)) == 0
                // AND to make sure our Archipelago identifier bit is 1 (this means we don't trigger off Steam ID 0)
                && (steamId & ArchipelagoIdentifierBit) == ArchipelagoIdentifierBit)
            {
                // AND to get the slot number
                playerId = (int)(steamId & ArchipelagoPlayerIdBitsMask);
                return true;
            }
            else
            {
                playerId = 0;
                return false;
            }
        }

        /// <summary>
        /// Generates an invalid SteamID for an Archipelago ID. This should only be used within
        /// the context of Raftipelgo
        /// </summary>
        /// <param name="playerId"></param>
        /// <returns></returns>
        public static CSteamID GetFakeSteamIDForArchipelagoPlayerId(int playerId)
        {
            return new CSteamID((ulong)(0x10000 | playerId));
        }

        public static T TryGetOrKey<T>(IDictionary<T, T> dict, T key)
        {
            return dict.TryGetValue(key, out T val) ? val : key;
        }

        public static bool HasFinishedRelayStationQuest()
        {
            return QuestProgressTracker.HasFinishedQuest(QuestType.BalboaRelayStation1)
                && QuestProgressTracker.HasFinishedQuest(QuestType.BalboaRelayStation2)
                && QuestProgressTracker.HasFinishedQuest(QuestType.BalboaRelayStation3);
        }
    }
}
