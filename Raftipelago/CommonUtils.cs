using Raftipelago.Data;
using Steamworks;
using System;
using System.Collections.Generic;
using System.Reflection;

namespace Raftipelago
{
    // We could make extensions, but I don't want to have this in IntelliSense in case it implies
    // that the function is in Raft (thus making it more reliable when updates happen) instead of
    // in our code. Because of this, extensions should not be used for Raft classes.
    public class CommonUtils
    {
        private static Type RGD_Game_Raftipelago_Type;
        private static ConstructorInfo RGD_Game_Raftipelago_ConstructorInfo;
        private static FieldInfo unlockedItemsFieldInfo;
        private static uint ModNetworkBehaviourIndex = uint.MaxValue;

        private const ulong ArchipelagoIdentifierBitMask = 0x10000;
        private const ulong ArchipelagoPlayerIdBitsMask = 0xFFFF;
        private const ulong AllArchipelagoBitsMask = 0x1FFFF;

        public static void Reset()
        {
            ModNetworkBehaviourIndex = uint.MaxValue;
        }

        public static uint GetNetworkBehaviourUniqueIndex()
        {
            return ModNetworkBehaviourIndex--;
        }

        public static bool IsNote(LandmarkItem item)
        {
            var name = item?.name ?? "";
            return name.Contains("NoteBookPickup");
        }
        public static bool IsBlueprint(LandmarkItem item)
        {
            var name = item?.name ?? "";
            return name.Contains("Blueprint");
        }
        public static bool IsNoteOrBlueprint(LandmarkItem item)
        {
            return IsNote(item) || IsBlueprint(item);
        }
        public static bool IsCharacter(LandmarkItem item)
        {
            return item?.name?.StartsWith("CharacterUnlock_") ?? false;
        }

        public static bool IsValidNote(NoteBookNote note)
        {
            return note?.name?.Contains("NoteBookNote") ?? false;
        }

        public static bool IsValidUnlockableItem(Item_Base item)
        {
            return item.settings_recipe.CraftingCategory != CraftingCategory.Hidden
                && item.settings_recipe.CraftingCategory != CraftingCategory.Decorations
                && item.settings_recipe.CraftingCategory != CraftingCategory.CreativeMode
                && item.settings_recipe.CraftingCategory != CraftingCategory.Skin
                && !item.settings_recipe.LearnedFromBeginning;
        }

        public static bool IsValidResearchTableItem(Item_Base item)
        {
            return !item.settings_recipe.HiddenInResearchTable
                && !item.settings_recipe.LearnedViaBlueprint
                && !item.settings_recipe.LearnedFromBeginning;
        }

        /// <summary>
        /// Gets the Archipelago Player ID from a SteamID. The SteamID given should NOT be a valid SteamID,
        /// but should instead be one generated by Raftipelago.
        /// </summary>
        /// <param name="steamId">The Raftipelago-generated SteamID</param>
        /// <param name="playerId">The parsed Player ID, or 0 if not a Raftipelago-generated SteamID</param>
        /// <returns>True if steamId was a valid Raftipelago-generated SteamID, otherwise false</returns>
        public static bool TryGetArchipelagoPlayerIdFromSteamId(ulong steamId, out int playerId)
        {
            // See https://developer.valvesoftware.com/wiki/SteamID for how to parse Steam IDs.
            // We're using the fact that the Universe for a Steam ID is Invalid at 0 to tell us
            // that this is an Archipelago player. This allows us to pass back Steam IDs without
            // having to override a bunch of additional methods and not accidentally conflict
            // with valid Steam IDs while doing so.
            // In our case, our custom SteamID is in the range 0x10000 - 0x1FFFF
            if (
                // XOR to check bits 18-64 are 0 so we know this is considered an invalid SteamID
                (steamId & (long.MaxValue - AllArchipelagoBitsMask)) == 0
                // AND to make sure our Archipelago identifier bit is 1 (this means we don't trigger off Steam ID 0)
                && (steamId & ArchipelagoIdentifierBitMask) == ArchipelagoIdentifierBitMask)
            {
                // AND to get the slot number
                playerId = (int)(steamId & ArchipelagoPlayerIdBitsMask);
                return true;
            }
            else
            {
                playerId = 0;
                return false;
            }
        }

        /// <summary>
        /// Generates an invalid SteamID for an Archipelago ID. This should only be used within
        /// the context of Raftipelgo
        /// </summary>
        /// <param name="playerId"></param>
        /// <returns></returns>
        public static CSteamID GetFakeSteamIDForArchipelagoPlayerId(int playerId)
        {
            return new CSteamID((ulong)(0x10000 | playerId));
        }

        public static T TryGetOrKey<T>(IDictionary<T, T> dict, T key)
        {
            return dict.TryGetValue(key, out T val) ? val : key;
        }

        public static bool HasFinishedRelayStationQuest()
        {
            return QuestProgressTracker.HasFinishedQuest(QuestType.BalboaRelayStation1)
                && QuestProgressTracker.HasFinishedQuest(QuestType.BalboaRelayStation2)
                && QuestProgressTracker.HasFinishedQuest(QuestType.BalboaRelayStation3);
        }

        public static bool HasCompletedTheGame()
        {
            return QuestProgressTracker.HasFinishedQuest(QuestType.Utopia_People_Rescued);
        }

        public static RGD_Game CreateRaftipelagoGame(RGD_Game baseData)
        {
            if (RGD_Game_Raftipelago_Type == null)
            {
                RGD_Game_Raftipelago_Type = ComponentManager<AssemblyManager>.Value.GetAssembly(AssemblyManager.RaftipelagoTypesAssembly).GetType("RaftipelagoTypes.RGD_Game_Raftipelago");
            }
            if (RGD_Game_Raftipelago_ConstructorInfo == null)
            {
                RGD_Game_Raftipelago_ConstructorInfo = RGD_Game_Raftipelago_Type.GetConstructor(new Type[] { typeof(RGD_Game) });
            }
            var newGame = (RGD_Game)RGD_Game_Raftipelago_ConstructorInfo.Invoke(new object[] { baseData });
            return newGame;
        }

        public static bool IsValidRaftipelagoSave(RGD_Game game)
        {
            return GetUnlockedItemIdentifiers(game)?.Count >= 0;
        }

        public static List<long> GetUnlockedItemIdentifiers(object gameData)
        {
            if (gameData == null)
            {
                Logger.Debug("gameData is null");
                return null;
            }
            if (RGD_Game_Raftipelago_Type == null)
            {
                RGD_Game_Raftipelago_Type = ComponentManager<AssemblyManager>.Value.GetAssembly(AssemblyManager.RaftipelagoTypesAssembly).GetType("RaftipelagoTypes.RGD_Game_Raftipelago");
            }
            if (unlockedItemsFieldInfo == null)
            {
                unlockedItemsFieldInfo = RGD_Game_Raftipelago_Type.GetField("Raftipelago_ReceivedItems");
            }

            if (gameData.GetType() != RGD_Game_Raftipelago_Type)
            {
                Logger.Debug("gameData is not Raftipelago save type");
                return null;
            }
            var resultingValue = unlockedItemsFieldInfo.GetValue(gameData);
            Logger.Debug($"Value from world is {(resultingValue == null ? "invalid" : $"[{string.Join(",", (List<long>)resultingValue)}]")}");
            return new List<long>((List<long>)unlockedItemsFieldInfo.GetValue(gameData));
        }

        public static void SetUnlockedItemIdentifiers(object gameData, List<long> itemPacks)
        {
            if (gameData == null)
            {
                Logger.Debug("gameData is null");
                return;
            }
            if (RGD_Game_Raftipelago_Type == null)
            {
                RGD_Game_Raftipelago_Type = ComponentManager<AssemblyManager>.Value.GetAssembly(AssemblyManager.RaftipelagoTypesAssembly).GetType("RaftipelagoTypes.RGD_Game_Raftipelago");
            }
            if (unlockedItemsFieldInfo == null)
            {
                unlockedItemsFieldInfo = RGD_Game_Raftipelago_Type.GetField("Raftipelago_ReceivedItems");
            }

            if (gameData.GetType() != RGD_Game_Raftipelago_Type)
            {
                Logger.Debug("gameData is not Raftipelago save type");
                return;
            }
            unlockedItemsFieldInfo.SetValue(gameData, new List<long>(itemPacks));
        }
    }
}
